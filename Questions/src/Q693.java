/**
 *
 * 给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。
 *
 * 输入：n = 5
 * 输出：true
 * 解释：5 的二进制表示是：101
 *
 *
 * @author chendong09
 * @since 2022/03/28
 */
public class Q693 {

    /**
     * 对输入 nn 的二进制表示右移一位后，得到的数字再与 nn 按位异或得到 aa。当且仅当输入 nn 为交替位二进制数时，
     * aa 的二进制表示全为 11（不包括前导 00）。这里进行简单证明：当 aa 的某一位为 11 时，当且仅当 nn 的对应位和其前一位相异。
     * 当 aa 的每一位为 11 时，当且仅当 nn 的所有相邻位相异，即 nn 为交替位二进制数。
     *
     * 将 aa 与 a + 1a+1 按位与，当且仅当 aa 的二进制表示全为 11 时，结果为 00。这里进行简单证明：
     * 当且仅当 aa 的二进制表示全为 11 时，a + 1a+1 可以进位，并将原最高位置为 00，按位与的结果为 00。
     * 否则，不会产生进位，两个最高位都为 11，相与结果不为 00。
     *
     * 结合上述两步，可以判断输入是否为交替位二进制数。
     *
     * 101
     * ^
     * 010
     * =
     * 111
     *
     * 111
     * &
     * 000
     * =
     * 0
     *
     * @param n
     * @return
     */
    public boolean hasAlternatingBits(int n) {
        int a = n ^ (n >> 1);
        return (a & (a + 1)) == 0;
    }
}
